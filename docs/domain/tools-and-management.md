# ユビキタス言語の管理方法とツール

## 管理ツールの選択

### 1. Notion（最も一般的）

#### 特徴
- データベース機能により用語を構造化して管理
- 検索性が高い
- チーム全体で簡単にアクセス可能
- リッチテキストで詳細な説明を記載可能

#### 推奨される構成

**用語データベースの項目:**
- **用語名**: ユビキタス言語の用語
- **英語名**: コードで使用される英語表記
- **定義**: 明確で簡潔な説明
- **使用例**: 実際の使用シーン
- **関連用語**: 他の用語との関係
- **コンテキスト**: どの境界づけられたコンテキストで使用されるか
- **ステータス**: 提案中/承認済み/非推奨
- **更新日**: 最終更新日時
- **担当者**: 定義を管理する担当者

**ビューの設定:**
- アルファベット順ビュー
- コンテキスト別ビュー
- 最近更新された用語ビュー
- ステータス別ビュー

#### メリット
- 導入が容易
- 柔軟なカスタマイズ
- リアルタイム同期
- コメント機能で議論が可能

#### デメリット
- バージョン管理が弱い
- コードとの自動同期が困難
- オフライン利用に制限

### 2. GitHub（バージョン管理重視）

#### 特徴
- Markdownファイルで用語を管理
- Git履歴で変更を追跡
- プルリクエストで用語の追加・変更をレビュー
- CI/CDで自動チェック可能

#### 推奨される構成

**ディレクトリ構造:**
```
/docs/ubiquitous-language/
  ├── README.md              # 概要と使い方
  ├── glossary/
  │   ├── customer.md        # 用語ごとにファイル
  │   ├── order.md
  │   └── payment.md
  ├── contexts/
  │   ├── sales.md           # コンテキストごとの用語リスト
  │   └── support.md
  └── changelog.md           # 変更履歴
```

**用語ファイルのテンプレート:**
```markdown
# [用語名]

## 定義
[明確で簡潔な定義]

## 英語名
[コードで使用される名前]

## コンテキスト
- [境界づけられたコンテキスト名]

## 使用例
[実際の使用シーン]

## 関連用語
- [関連する用語へのリンク]

## コード例
```typescript
[実装例]
```

## 履歴
- YYYY-MM-DD: [変更内容]
```

#### メリット
- 完全なバージョン管理
- レビュープロセスの確立
- コードと同じリポジトリで管理可能
- 変更履歴の追跡が容易

#### デメリット
- Gitの知識が必要
- 検索性がNotionより劣る
- 非エンジニアには敷居が高い

### 3. Confluence

#### 特徴
- エンタープライズ向けドキュメント管理
- Jiraとの統合
- 強力な検索機能
- 詳細な権限管理

#### メリット
- 既存のAtlassianエコシステムとの統合
- 強力な権限管理
- テンプレート機能

#### デメリット
- コストが高い
- セットアップが複雑
- 動作が重い場合がある

### 4. ハイブリッドアプローチ（Notion + GitHub）

#### 実践例
一部のチームは、NotionとGitHubの両方を使用する実験的なアプローチを採用しています。

**使い分け:**
- **Notion**: チーム全体での議論と日常的な参照
- **GitHub**: 正式な用語の確定とバージョン管理

**ワークフロー:**
1. Notionで用語の提案と議論
2. 合意が得られたらGitHubにプルリクエストを作成
3. レビュー後、GitHubにマージ
4. 定期的にGitHubの内容をNotionに反映

#### メリット
- 両方の利点を活用
- 議論の柔軟性と正式性の両立

#### デメリット
- 二重管理の手間
- 同期の負担
- 複雑さの増加

## 管理プロセス

### 1. 用語の提案プロセス

#### ステップ1: 提案
誰でも新しい用語を提案できるようにします。

**提案時の必須情報:**
- 用語名
- 定義
- 使用するコンテキスト
- なぜこの用語が必要か

#### ステップ2: 議論
チーム全体で用語の妥当性を議論します。

**議論のポイント:**
- 既存の用語と重複していないか
- 定義は明確か
- ドメインエキスパートの視点
- 実装の観点

#### ステップ3: 承認
合意が得られたら正式に承認します。

**承認基準:**
- ドメインエキスパートの同意
- 開発チームの理解
- 定義の明確性
- 実装可能性

#### ステップ4: 公開
承認された用語をチーム全体に周知します。

**周知方法:**
- Slackでの通知
- リリースノートの発行
- チームミーティングでの共有

### 2. 用語の更新プロセス

#### トリガー
- ドメイン知識の深化
- 要件の変更
- 曖昧さの発見
- より良い表現の発見

#### 更新手順
1. 変更提案を作成
2. 影響範囲の調査（どのコードで使用されているか）
3. チームでの議論
4. 承認
5. コードの更新
6. ドキュメントの更新

### 3. 用語の廃止プロセス

#### 廃止の理由
- より適切な用語が見つかった
- ドメインモデルの変更
- 使用されなくなった

#### 廃止手順
1. 廃止提案
2. 代替案の提示
3. 移行計画の策定
4. 段階的な置き換え
5. 正式な廃止
6. 履歴としての保持（削除はしない）

## 自動化とツール連携

### Slackワークフロー

#### 用語追加リクエスト
```
トリガー: /ubiquitous-language-add
入力フィールド:
  - 用語名
  - 定義
  - コンテキスト
  - 使用例
アクション:
  - Notionに下書きとして追加
  - 専用チャンネルに通知
  - レビュアーにメンション
```

#### リリースノート自動生成
```
トリガー: Notionで用語のステータスが「承認済み」に変更
アクション:
  - リリースノートを生成
  - Slackの全体チャンネルに投稿
  - 関連するGitHub Issueを更新
```

### CI/CDでの検証

#### コード内の用語チェック
```yaml
# .github/workflows/ubiquitous-language-check.yml
name: Ubiquitous Language Check

on: [pull_request]

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Check for unapproved terms
        run: |
          # 承認された用語リストと比較
          # 未承認の用語があれば警告
```

#### ドキュメント同期チェック
```yaml
# コードとドキュメントの用語使用が一致しているか確認
- name: Sync check
  run: |
    # コード内の用語を抽出
    # ドキュメントと比較
    # 不一致があれば警告
```

## ベストプラクティス

### 1. アクセシビリティ
- チーム全員が簡単にアクセスできる場所に配置
- 検索しやすい構造
- モバイルからもアクセス可能

### 2. 最新性の維持
- 定期的なレビュー（月1回など）
- 更新通知の仕組み
- 古い情報の整理

### 3. 使いやすさ
- シンプルな構造
- 明確な命名規則
- 豊富な例

### 4. 継続性
- 管理者の明確化
- 更新プロセスの標準化
- チーム文化としての定着

## 測定と改善

### メトリクス

#### 用語の使用状況
- コード内での使用頻度
- ドキュメントでの参照回数
- 会話での登場頻度

#### 品質指標
- 曖昧さに関する問い合わせ数
- 用語の変更頻度（安定性）
- チームメンバーの理解度（アンケート）

#### プロセス指標
- 提案から承認までの期間
- レビューの参加率
- 更新の頻度

### 改善サイクル

1. **測定**: 上記メトリクスを定期的に収集
2. **分析**: 問題点や改善点を特定
3. **計画**: 改善策を立案
4. **実行**: 改善を実施
5. **評価**: 効果を確認

このサイクルを継続的に回すことで、ユビキタス言語の管理プロセスを最適化します。
